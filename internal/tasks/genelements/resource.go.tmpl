package resources

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/koki-develop/terraform-provider-html/internal/provider"
	"github.com/koki-develop/terraform-provider-html/internal/util"
)

var (
	_ resource.Resource = &resource_{{ .Element.Name }}{}
)

func newResource_{{ .Element.Name }}() resource.Resource {
	return &resource_{{ .Element.Name }}{}
}

type resource_{{ .Element.Name }} struct{}

func (r *resource_{{ .Element.Name }}) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{ .Element.Name }}"
}

func (r *resource_{{ .Element.Name }}) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "{{ .Element.Description }}",
		Attributes: map[string]schema.Attribute{
			{{- range .Element.Attributes }}
			"{{ .Name }}": schema.DynamicAttribute{
				MarkdownDescription: "{{ .Description }}",
				Optional:            true,
			},
			{{- end }}
			{{- range .GlobalAttributes }}
			"{{ .Name }}": schema.DynamicAttribute{
				MarkdownDescription: "{{ .Description }}",
				Optional:            true,
			},
			{{- end }}

			"html": schema.StringAttribute{
				MarkdownDescription: "The html of the element.",
				Computed:            true,
			},
		},
	}
}

type resource_{{ .Element.Name }}Model struct {
	{{- range .Element.Attributes }}
	_{{ .Name }} types.Dynamic `tfsdk:"{{ .Name }}"`
	{{- end }}
	{{- range .GlobalAttributes }}
	_{{ .Name }} types.Dynamic `tfsdk:"{{ .Name }}"`
	{{- end }}

	HTML types.String `tfsdk:"html"`
}

func (r *resource_{{ .Element.Name }}) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	r.handleRequest(ctx, &req.Plan, &resp.State, &resp.Diagnostics)
}

func (r *resource_{{ .Element.Name }}) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	r.handleRequest(ctx, &req.State, &resp.State, &resp.Diagnostics)
}

func (r *resource_{{ .Element.Name }}) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	r.handleRequest(ctx, &req.Plan, &resp.State, &resp.Diagnostics)
}

func (r *resource_{{ .Element.Name }}) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
}

func (r *resource_{{ .Element.Name }}) handleRequest(ctx context.Context, g util.ModelGetter, s util.ModelSetter, diags *diag.Diagnostics) {
	util.HandleRequest(
		ctx,
		&resource_{{ .Element.Name }}Model{},
		g,
		s,
		diags,
		func(m *resource_{{ .Element.Name }}Model) bool {
			html := new(strings.Builder)
			html.WriteString("<{{ .Element.Name }}")

			attrs := []string{}
			{{- range .Element.Attributes }}
			if !m._{{ .Name }}.IsNull() {
				attr, err := util.StringifyAttribute(ctx, "{{ .Name }}", m._{{ .Name }})
				if err != nil {
					diags.AddError("invalid {{ .Name }} attribute", err.Error())
					return false
				}
				attrs = append(attrs, attr)
			}
			{{- end }}

			if len(attrs) > 0 {
				html.WriteString(" ")
				html.WriteString(strings.Join(attrs, " "))
			}
			html.WriteString(">")

			// TODO: children

			html.WriteString("</{{ .Element.Name }}>")
			m.HTML = types.StringValue(html.String())
			return true
		},
	)
}

func init() {
	register(newResource_{{ .Element.Name }})
}
