package resources

import (
	"context"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/koki-develop/terraform-provider-html/internal/util"
)

var (
	_ resource.Resource = &resource_{{ .Element.Name }}{}
)

func newResource_{{ .Element.Name }}() resource.Resource {
	return &resource_{{ .Element.Name }}{}
}

type resource_{{ .Element.Name }} struct{}

func (r *resource_{{ .Element.Name }}) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{ .Element.Name }}"
}

func (r *resource_{{ .Element.Name }}) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "{{ .Element.Description | escape }}\n\nFor more information, see the [documentation]({{ .Element.URL }}).",
		Attributes: map[string]schema.Attribute{
			"children": schema.ListAttribute{
				ElementType:         types.StringType,
				MarkdownDescription: "The children of the element.",
				Optional:            true,
			},

			{{- range .Element.Attributes }}
			"{{ .Name }}": schema.DynamicAttribute{
				MarkdownDescription: "{{ .Description | escape }}",
				Optional:            true,
			},
			{{- end }}
			{{- range .GlobalAttributes }}
			"{{ .Name }}": schema.DynamicAttribute{
				MarkdownDescription: "{{ .Description | escape }} ([Documentation]({{ .URL }}))",
				Optional:            true,
			},
			{{- end }}

			"html": schema.StringAttribute{
				MarkdownDescription: "The html of the element.",
				Computed:            true,
			},
		},
	}
}

type resource_{{ .Element.Name }}Model struct {
	Children types.List `tfsdk:"children"`

	{{- range .Element.Attributes }}
	{{ .Name | title }} types.Dynamic `tfsdk:"{{ .Name }}"`
	{{- end }}
	{{- range .GlobalAttributes }}
	{{ .Name | title }} types.Dynamic `tfsdk:"{{ .Name }}"`
	{{- end }}

	HTML types.String `tfsdk:"html"`
}

func (r *resource_{{ .Element.Name }}) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	r.handleRequest(ctx, &req.Plan, &resp.State, &resp.Diagnostics)
}

func (r *resource_{{ .Element.Name }}) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	r.handleRequest(ctx, &req.State, &resp.State, &resp.Diagnostics)
}

func (r *resource_{{ .Element.Name }}) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	r.handleRequest(ctx, &req.Plan, &resp.State, &resp.Diagnostics)
}

func (r *resource_{{ .Element.Name }}) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
}

func (r *resource_{{ .Element.Name }}) handleRequest(ctx context.Context, g util.ModelGetter, s util.ModelSetter, diags *diag.Diagnostics) {
	util.HandleRequest(
		ctx,
		&resource_{{ .Element.Name }}Model{},
		g,
		s,
		diags,
		func(m *resource_{{ .Element.Name }}Model) bool {
			html := new(strings.Builder)
			html.WriteString("<{{ .Element.Name }}")

			attrs := []string{}
			{{- range .Element.Attributes }}
			if !m.{{ .Name | title }}.IsNull() {
				attr, err := util.StringifyAttribute(ctx, "{{ .Name }}", m.{{ .Name | title }})
				if err != nil {
					diags.AddError("invalid {{ .Name }} attribute", err.Error())
					return false
				}
				attrs = append(attrs, attr)
			}
			{{- end }}
			{{- range .GlobalAttributes }}
			if !m.{{ .Name | title }}.IsNull() {
				attr, err := util.StringifyAttribute(ctx, "{{ .Name }}", m.{{ .Name | title }})
				if err != nil {
					diags.AddError("invalid {{ .Name }} attribute", err.Error())
					return false
				}
				attrs = append(attrs, attr)
			}
			{{- end }}

			if len(attrs) > 0 {
				html.WriteString(" ")
				html.WriteString(strings.Join(attrs, " "))
			}

			if m.Children.IsNull() {
				if len(attrs) > 0 {
					html.WriteString(" ")
				}
				html.WriteString("/>")
			} else {
				html.WriteString(">")

				var children []string
				d := m.Children.ElementsAs(ctx, &children, true)
				diags.Append(d...)
				if diags.HasError() {
					return false
				}
				for _, child := range children {
					html.WriteString(child)
				}
				html.WriteString("</{{ .Element.Name }}>")
			}

			m.HTML = types.StringValue(html.String())
			return true
		},
	)
}

func init() {
	register(newResource_{{ .Element.Name }})
}
