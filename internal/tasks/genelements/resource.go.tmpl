package resources

import (
	"context"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/koki-develop/terraform-provider-html/internal/util"
)

var (
	_ resource.Resource = &resource_{{ .Name }}{}
)

func newResource_{{ .Name }}() resource.Resource {
	return &resource_{{ .Name }}{}
}

type resource_{{ .Name }} struct{}

func (r *resource_{{ .Name }}) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{ .Name }}"
}

func (r *resource_{{ .Name }}) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "{{ .Description | escape }}\n\nFor more information, see the [documentation]({{ .URL }}).",
		Attributes: map[string]schema.Attribute{
			"children": schema.ListAttribute{
				ElementType:         types.StringType,
				MarkdownDescription: "The children of the element.",
				Optional:            true,
			},

			{{- range .Attributes }}
			"{{ .Name }}": schema.DynamicAttribute{
				MarkdownDescription: "{{ .Description | escape }}{{ if .URL }} ([Documentation]({{ .URL }})){{ end }}",
				Optional:            true,
			},
			{{- end }}

			"html": schema.StringAttribute{
				MarkdownDescription: "The html of the element.",
				Computed:            true,
			},
		},
	}
}

type resource_{{ .Name }}Model struct {
	Children types.List `tfsdk:"children"`

	{{- range .Attributes }}
	{{ .Name | title }} types.Dynamic `tfsdk:"{{ .Name }}"`
	{{- end }}

	HTML types.String `tfsdk:"html"`
}

func (r *resource_{{ .Name }}) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	r.handleRequest(ctx, &req.Plan, &resp.State, &resp.Diagnostics)
}

func (r *resource_{{ .Name }}) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	r.handleRequest(ctx, &req.State, &resp.State, &resp.Diagnostics)
}

func (r *resource_{{ .Name }}) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	r.handleRequest(ctx, &req.Plan, &resp.State, &resp.Diagnostics)
}

func (r *resource_{{ .Name }}) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
}

func (r *resource_{{ .Name }}) handleRequest(ctx context.Context, g util.ModelGetter, s util.ModelSetter, diags *diag.Diagnostics) {
	util.HandleRequest(
		ctx,
		&resource_{{ .Name }}Model{},
		g,
		s,
		diags,
		func(m *resource_{{ .Name }}Model) bool {
			html := new(strings.Builder)
			html.WriteString("<{{ .Name }}")

			attrs := []string{}
			{{- range .Attributes }}
			if !m.{{ .Name | title }}.IsNull() {
				attr, err := util.StringifyAttribute(ctx, "{{ .Name }}", m.{{ .Name | title }})
				if err != nil {
					diags.AddError("invalid {{ .Name }} attribute", err.Error())
					return false
				}
				attrs = append(attrs, attr)
			}
			{{- end }}

			if len(attrs) > 0 {
				html.WriteString(" ")
				html.WriteString(strings.Join(attrs, " "))
			}

			if m.Children.IsNull() {
				if len(attrs) > 0 {
					html.WriteString(" ")
				}
				html.WriteString("/>")
			} else {
				html.WriteString(">")

				var children []string
				d := m.Children.ElementsAs(ctx, &children, true)
				diags.Append(d...)
				if diags.HasError() {
					return false
				}
				for _, child := range children {
					html.WriteString(child)
				}
				html.WriteString("</{{ .Name }}>")
			}

			m.HTML = types.StringValue(html.String())
			return true
		},
	)
}

func init() {
	register(newResource_{{ .Name }})
}
